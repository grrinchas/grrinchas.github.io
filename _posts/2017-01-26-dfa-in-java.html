---
identity: POST100
layout: post
title: DFA in JAVA
category: Tutorial
comments: true
tags:
    - java
    - dfa
quote:
quote: There is no mistakes or failures, only lessons.
author: Denis Grinch
description: DFA (Deterministic Finite Automaton) implementation using JAVA.
definitions:
    - DEF100
    - DEF101
    - DEF102
    - DEF103
    - DEF104
    - DEF105
code:
    - id: SC100
      language: java
      lines: 14
headers:
    - id: H0
      name: Why do we need DFA?
    - id: H1
      name: Formal definition of DFA
    - id: H2
      name: State (transition) diagram
    - id: H3
      name: Extended transition function
    - id: H4
      name: Regular languages
    - id: H5
      name: Transition table
    - id: H6
      name: DFA implementation in JAVA
images:
    - id: IMG100
      alt: State diagram of DFA.
      src: /resources/images/automata.svg
      caption: State diagram of DFA which recognises language from <a href="#task-1">Task 1</a>.
    - id: IMG100
      alt: State diagram of DFA
      src: /resources/images/automata_2.svg
tables:
    - id: TB100
      caption: Transition table.
---

<p>
    <strong>DFA (Deterministic Finite Automaton)</strong> sometimes called
    <strong>DFSM (Deterministic Finite State Machine)</strong>
    is a a finite state machine which given sequence of symbols accepts them or not.
</p>

<div class="success alert">
    <p><strong>NOTE:</strong> The difference between <strong>automaton**</strong> (singular) and
        <strong>automata</strong> (plural)
        terms.
    </p>
</div>

<h2><a name="{{ page.headers[0].id }}"></a>{{ page.headers[0].name }}</h2>

<p>
    <a name="task-1"></a>Lets, say you are given a task to write a program which accepts strings with following
    conditions:
</p>

<ol>
    <li>It must contain only
        <code class="d-code">:</code>,
        <code class="d-code">)</code>,
        <code class="d-code">(</code>, and
        <code class="d-code">_</code> characters.
    </li>
    <li>
        <code class="d-code">:</code>has to be followed by<code class="d-code">)</code> or <code class="d-code">(</code>
    </li>
    <li>Has to have least one smiley <code class="d-code">:)</code> or sad <code class="d-code">:(</code>face.</li>
    <li>If string has more than one face, then all of them have to be separated by at least one <code
                class="d-code">_</code> character.
    </li>
    <li>Each string can start or end with zero or more <code class="d-code">_</code> characters.</li>
</ol>

<p>
    Of course, this task can be easily accomplished using regular expressions. But for the sake of argument, let's say
    we
    can't use them. In fact, behind the scenes, all regular expressions are transformed into automaton anyway.
</p>

<p>
    One way to accomplish this task is to create method with a <code class="d-code">for</code> loop and deeply nested
    <code class="d-code">if</code> statements in it. Loop
    will go through each character and checks if it is acceptable, based on previous characters. The problem is that,
    there
    are lots of cases to consider, thus making this approach error prone.
</p>

<p>
    Another way of thinking about it, is to imagine that a program (DFA) has finite set of states. For example, a state
    when it
    begins reading characters, a state after last character, and intermediate states which it visits between
    start and finish. A transition between states are based on two things:
</p>

<ol>
    <li>Current state.</li>
    <li>Read in character.</li>
</ol>

<p>
    There can be situations when different characters leads to the same state. For example, after reading
    <code class="d-code">:)</code> there are only one
    acceptable character <code class="d-code">_</code>, all other characters
    <code class="d-code">:</code>, <code class="d-code">)</code>, <code class="d-code">(</code> will lead to not
    acceptable state. Also, some characters will lead to the same current state. For example, if the first character
    was <code class="d-code">_</code>, then no matter how many of <code class="d-code">_</code>
    program will read in, all states <code class="d-code">_</code>, <code class="d-code">__</code>,
    <code class="d-code">_______</code> will not impact transition to the next state,
    thus current state will stay the same. If the DFA after reading last character will end up in state which
    is acceptable, then a string can be considered accepted.
</p>

<h2><a name="{{ page.headers[1].id }}"></a>{{ page.headers[1].name }}</h2>

<p>
    While we could create DFA using the reasoning presented earlier. There are some questions which begs an answer:
    <i>What exactly are start and accept states?</i> <i>Can it have zero accept states?</i>
    <i>Can it have more than one start state?</i> and so on. All these questions can be answered by looking at the
    definition of
    DFA.
</p>

{% for def in site.definitions %}
    {% if def.identity == page.definitions[0] %}
        <a name="{{ def.identity }}"></a>
        <div class="env-header">
            Definition {{ def.identity | remove: "DEF"  | split: "" | join: "." }}
        </div>
        <div class="definition alert">
            {{ def.content }}
        </div>
    {% endif %}
{% endfor %}

<p>
The first thing what we should notice is that DFA is defined as 5-tuple. Meaning that it has five elements and order
of the elements matter, thus $$(Q, Σ, δ, q_0, F) \neq (Σ, Q, δ, q_0, F)$$. First element $$Q$$ represents all the states
    which DFA has. In general, when we are talking about finite state machine, term <i>finite state</i> is analogous to $$Q$$.
</p>

<p>
Second element is an alphabet $$Σ$$ (read as <i>sigma</i>). It represents all the symbols which are allowed to go into machine.
For example, if $$Σ = \{0, 1, 2\}$$, then only characters $$1$$, $$2$$, and $$3$$ are allowed. But what if we have more
symbols? In that case we have to modify DFA to support them. Remember that we are dealing with <strong>deterministic</strong> finite
automaton, meaning that it's next state is determined by input symbol, thus unrecognised symbols are not allowed.
Also, in alphabet symbols do not need to be one letter characters. For example, $$Σ = \{health, stamina, shield\}$$
is perfectly valid alphabet for game AI.
</p>

<p>
Third element is a function $$δ$$ (read as <i>delta</i>) where $$δ : Q × Σ → Q$$. It represents a transition from one state
to another. $$Q × Σ$$ is a domain of the function. From the set theory, we know that if we have two sets $$Q$$ and $$Σ$$,
    then their <strong>cartesian product</strong> $$Q × Σ$$ is a set of all the pairs $$(a, b)$$ where $$a ∈ Q$$ and $$b ∈ Σ$$. Codomain
of $$δ$$ is $$Q$$. In plain english function $$δ : Q × Σ → Q$$ says: <i>give me any sate and any symbol and I will return
a state</i>. Notice, it does not say that a <i>returned</i> state has to be different, it can be the same state as <i>given</i>.
</p>

<p>
Fourth element $$q_0$$ represents start state which has to be one of the states in $$Q$$. Also, by definition of the
start state, we can answer a question: <>can it have more than one state?</i>. No, it can't. Every DFA has to have only one
start state.
</p>

<p>
Lastly, fifth element $$F$$ represents set of accept states which is subset of $$Q$$. Notice the difference between $$∈$$
    and $$⊆$$. $$∈$$ means <strong>member of</strong>, thus start state $$q_0$$ is a member of $$Q$$. While $$⊆$$ means <strong>subset of</strong>, thus
$$F$$ is a subset of $$Q$$. We know that every set has empty set $$∅$$ as it's subset. Therefore, $$F$$ can be $$∅$$, meaning
that DFA can have zero accept states.
</p>

<h2><a name="{{ page.headers[2].id }}"></a>{{ page.headers[2].name }}</h2>

<p>
While formal definition is a nice way of defining DFA, it does not help us to visualise it.
On the other hand, state diagrams can be used to define and to visually representing finite automaton.
The only downside of them, is that state diagrams tend to be very messy if DFA's have many states.
Nevertheless, for simple ones is a perfect choice.
</p>

{% for def in site.definitions %}
    {% if def.identity == page.definitions[1] %}
        <a name="{{ def.identity }}"></a>
        <div class="env-header"> Definition {{ def.identity | remove: "DEF"  | split: "" | join: "." }} </div>
        <div class="definition alert"> {{ def.content }} </div>
    {% endif %}
{% endfor %}

<p>
For example, lets draw a state diagram for <a href="#task-1">Task 1</a>.
</p>

<figure>
	{% assign img = page.images[0] %}
	<a name="{{ img.id }}"></a>
	<img src="{{ img.src }}" alt="{{ img.alt }}"/>
	<figcaption>
		<strong>Image {{ img.id | remove: "IMG" | split: "" | join: "." }}:</strong> {{ img.caption }}
	</figcaption>
</figure>

<p>
We can see that nodes represents states, while arcs - transitions from one state to another. Transitions are based on
current state and input symbol. For example, if automaton's current state is $$q_0$$ and the input symbol is <code class="d-code">:</code>,
then it goes to $$q_1$$. If the input symbol is <code class="d-code">_</code>, then it transitions to its current state ($$q_0$$). Notice that one
arrow pointing to $$q_0$$ does not originate from any node, thus by

<a href="#{{ page.definitions[1] }}">Definition {{ page.definitions[1] | remove: "DEF" | split: "" | join: "." }}</a>

of $$q_0$$ is a start state. And nodes with double circle $$q_2$$ and $$q_3$$ represent accept states.
One special type of non accepting states are those which has
only arrows pointing to it but has no arrows pointing to other states. Thus, if any transition
leads to that kind of state, then it is dead end because it is impossible to reach an accepting state,
    these states are called <strong>dead states</strong>. For example, $$q_4$$.
</p>

<div class="success alert">
<strong>NOTE:</strong> While it is not necessary, I color coded states in the state diagram. Thus, orange stands for start, green
- accept and red for dead states.
</div>


<h2><a name="{{ page.headers[3].id }}"></a>{{ page.headers[3].name }}</h2>

<p>
At this point we only talked about transitions as a separate functions. That is, given current state and an input symbol,
DFA transitions to next state or current. Then, that state becomes an input for the next transition function,
and so on. This cycle repeats until there are no more input symbols. Thus, producing a sequence of state transitions. This
    sequence can be expressed by <strong>extended transition function</strong> denoted by $$δ^*$$. This function is very similar to $$δ$$,
they both take state as an input and return state as an output. But contrary to $$δ$$, function $$δ^*$$ takes not a symbol
from the alphabet $$Σ$$ but a string consisting of symbols from the alphabet $$Σ$$. So, if the input state is a start state $$q_0$$, then
given a string, $$δ^*$$ will return a state, which we would get after following sequence of state transitions. Maybe
formal definition will be more understandable.
    </p>

{% for def in site.definitions %}
    {% if def.identity == page.definitions[2] %}
        <a name="{{ def.identity }}"></a>
        <div class="env-header"> Definition {{ def.identity | remove: "DEF"  | split: "" | join: "." }} </div>
        <div class="definition alert"> {{ def.content }} </div>
    {% endif %}
{% endfor %}

<p>
Or maybe not :). The problem is that, $$δ^*$$ is defined recursively. We have a base case <i>1.</i> and then we define it
recursively <i>2.</i>. Anyway, if you look more closely, then you would see a main difference between
$$ δ^* : Q × Σ^* → Q $$ and $$ δ : Q × Σ → Q $$. Contrary to $$δ$$'s domain $$Q × Σ$$, extended transition
function's domain $$Q × Σ^*$$ is a cartesian product of set of states $$Q$$ and
<a href="https://en.wikipedia.org/wiki/Kleene_star">Kleene Star</a> $$*$$ over alphabet $$Σ$$ denoted by $$Σ^*$$. Lets call it a
    <strong>Kleene closure</strong>, which is a set of all strings over alphabet $$Σ$$, including the empty string $$ε$$. For example,
</p>

<p>
If $$Σ = \{aa, b\}$$, then $$Σ^* = \{ε, aa, b, aab, baa, aaaa, bb, aaaab, \dots \}$$
    </p>

<p>
    You may ask: <i>why do wee need it?</i> Remember when I said, that automaton accepts strings where each symbol is in alphabet $$Σ$$.
So Kleene closure is a nice way of representing all those strings.
</p>

<p>
After defining $$δ^∗$$ signature, we need to define how it functions. We start with the base case, which says that
for every $$q ∈ Q$$, $$δ^∗(q, ε) = q$$. In plain english, function $$δ^∗$$ says: <i>give me any state and empty string and
    I will give you back the same state</i>. It may sound useless, but in fact it is very important case because, as we
will see, it terminates a function. Empty string $$ε$$ indicates the end of the string, so it makes sense to return
input state. Just like $$δ$$ transition would return the state after last input symbol.
</p>

<p class="bottomless">
    Recursive case defines function for those cases when a string is not empty. $$ya$$ in $$δ^∗(q, ya)$$ means, <strong>concatenation</strong>
    between a string $$y$$ from $$Σ^*$$ and one symbol $$a$$ from the alphabet $$Σ$$. This is just another
    representation of
    original string. Advantage of $$ya$$ is that we can use different parts of it to define $$δ^∗(q, ya)$$.
</p>

$$$δ^∗(q, ya ) = δ(δ^∗(q, y), a )$$$

<p>
As you can see it is equal to the original transition function $$δ$$ from the definition of $$M$$. First argument of
it is extended transition function $$δ^∗$$ with two arguments: a state and a string which is one symbol shorter than,
original $$ya$$. And the last argument of $$δ$$ is symbol $$a$$ from original $$ya$$ string. For example, given
following state diagram,
</p>

<figure>
    {% assign img = page.images[1] %}
    <a name="{{ img.id }}"></a>
    <img src="{{ img.src }}" alt="{{ img.alt }}"/>
</figure>

<p class="bottomless">
and the string $$abc$$, we can trace $$δ^∗(q_0, abc)$$ function,
</p>

$$$
\begin{align} δ^∗(q_0, abc) &= δ(δ^∗(q_0, ab), c) \\
&= δ(δ(δ^∗(q_0, a), b), c) \\
&= δ(δ(δ(δ^∗(q_0, ε), a), b), c) \\
&= δ(δ(δ(q_0, a), b), c) \\
&= δ(δ(q_1, b), c) \\
&= δ(q_2, c) \\
&= q_3
\end{align}
$$$


<h2><a name="{{ page.headers[4].id }}"></a>{{ page.headers[4].name }}</h2>

<p>
Using <a href="#{{ page.definitions[2] }}">Definition {{ page.definitions[2] | remove: "DEF" | split: "" | join: "." }}</a>
of extended transition function $$δ^∗$$ we can precisely define what it means for DFA to
    <strong>accept</strong> or to <strong>reject</strong> a string.
</p>

{% for def in site.definitions %}
    {% if def.identity == page.definitions[3] %}
        <a name="{{ def.identity }}"></a>
        <div class="env-header">
            Definition {{ def.identity | remove: "DEF"  | split: "" | join: "." }}
        </div>
        <div class="definition alert">
            {{ def.content }}
        </div>
    {% endif %}
{% endfor %}

<p>
Basically string $$a$$ is accepted by automaton $$M$$ if given start state $$q_0$$ and $$a$$ extended transition function
$$δ^*$$ returns an accept state. Which makes sense. Then we can ask ourselves: <i>how would we call all the strings
which automaton accepts?</i> Well, we can think of strings as words, then set of words over alphabet is a language. Thus,
we can say that set of the strings, which automaton accepts, is a language which automaton <strong>recognises</strong>. Some may say
that automaton accepts a language, but that is ambiguous with automaton accepting a string. So, to make it clear, we will
say that automation <strong>accepts</strong> a string, but <strong>recognises</strong> a language. More formally,
</p>

{% for def in site.definitions %}
    {% if def.identity == page.definitions[4] %}
        <a name="{{ def.identity }}"></a>
        <div class="env-header">
            Definition {{ def.identity | remove: "DEF"  | split: "" | join: "." }}
        </div>
        <div class="definition alert">
            {{ def.content }}
        </div>
    {% endif %}
{% endfor %}

<p>
Notice that is not necessary for automaton to accept all the strings over alphabet $$Σ$$ to recognise a language.
It can accept one, two or even zero strings. In later case $$L(M) = ∅$$. We call a language <strong>regular</strong> if there is
a finite automaton which recognises it. More formally,
</p>

{% for def in site.definitions %}
    {% if def.identity == page.definitions[5] %}
        <a name="{{ def.identity }}"></a>
        <div class="env-header">
            Definition {{ def.identity | remove: "DEF"  | split: "" | join: "." }}
        </div>
        <div class="definition alert">
            {{ def.content }}
        </div>
    {% endif %}
{% endfor %}


<div class="success alert">
    <strong>NOTE:</strong> In <a href="#{{ page.definitions[5] }}">Definition {{ page.definitions[5] | remove: "DEF" | split: "" | join: "." }}</a>
 a language is called regular when <strong>any</strong> finite automaton recognises it.
Meaning that automaton can be DFA, NFA and other types of FSM.
</div>

<p class="bottomless">
Like I sad before, a language $$L$$ is only a subset of Kleene's closure $$Σ^*$$. And, if all the strings in
$$L$$ is also in a language which automaton recognises $$L(M)$$ then we say, that a language $$L$$ is regular. For example,
</p>

$$$L_1 = \{ xaaay\;|\;x, y ∈ \{a, b\}^∗\} ⊆ \{a, b\}^*$$$

<p>
is a regular language.
    </p>

<p>
Another example of regular language is presented in
    <a href="#task-1">Task 1</a> and
    <a href="#{{ page.images[0].id }}">Image {{ page.images[0].id | remove: "IMG" | split: "" | join: "." }}</a>
    shows an automaton which recognises it.
Below we can see some strings which are in the language, and some which are not,
</p>

<ul>
<li>
    <strong>Is:</strong>
    <code class="d-code">:)</code>,
    <code class="d-code">:(</code>,
    <code class="d-code">:(_:)</code>,
    <code class="d-code">:)___:)__:(__</code>,
    <code class="d-code">_________:)__</code>.
</li>
    <li>
        <strong>Is not:</strong>
        <code class="d-code">____</code>,
        <code class="d-code">::)</code>,
        <code class="d-code">:((</code>,
        <code class="d-code">:(:()</code>,
        <code class="d-code">:)_):)</code>,
        <code class="d-code">(:</code>.
    </li>
</ul>

<p>
So, if a string <code class="d-code">_:)__:(</code> is in the language then our DFA should accept it. Let's see how it does that.
</p>

<p>
Initially, DFA is in the $$q_0$$ state, then it receives
<code class="d-code">_</code> character, the arrow with it points to the same state $$q_0$$. Next character is <code class="d-code">:</code>, which points to $$q_1$$ state,
then following <code class="d-code">)</code> DFA goes to $$q_2$$ state. From there, we have <code class="d-code">_</code> to $$q_3$$, then one more <code class="d-code">_</code> from $$q_3$$ to itself.
After that, <code class="d-code">:</code> character points to $$q_1$$ and following <code class="d-code">(</code> DFA ends up in $$q_2$$ state.
As we can see, the last state is an accept state, thus automaton from
    <a href="#{{ page.images[0].id }}">Image {{ page.images[0].id | remove: "IMG" | split: "" | join: "." }}</a>
    <code class="d-code">_:)__:(</code>.
</p>

<h2><a name="{{ page.headers[5].id }}"></a>{{ page.headers[5].name }}</h2>

<p>
While we could use Given DFA in [Figure 1](#figure-1) its formal definition would be:
</p>

<p>
$$M = (Q, Σ, δ, q_0, F )$$$, where
</p>

<ol>
    <li>$$Q = \{q_0, q_1, q_2, q_3, q_4\}$$,</li>
    <li>$$Σ = \{$$<code class="d-code">_</code>$$,$$<code class="d-code">:</code>$$,$$<code class="d-code">)</code>$$,$$<code
                class="d-code">(</code>$$\}$$,
    </li>
    <li>$$q_0 = q_0$$,</li>
    <li>$$F = \{q_2, q_3\}$$.</li>
    <li>$$δ$$ is described as a <strong>transition table</strong></li>
</ol>


<figure class="table">

    <table>
        <thead>
        <tr>
            <th></th>
            <th>$$:$$ </th>
            <th>$$)$$ </th>
            <th>$$($$ </th>
            <th>$$\_$$ </th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <th>$$q_0$$ </th>
            <td>$$q_1$$ </td>
            <td>$$q_4$$ </td>
            <td>$$q_4$$ </td>
            <td>$$q_0$$ </td>
        </tr>
        <tr>
            <th>$$q_1$$ </th>
            <td>$$q_4$$ </td>
            <td>$$q_2$$ </td>
            <td>$$q_2$$ </td>
            <td>$$q_4$$ </td>
        </tr>
        <tr>
            <th>$$q_2$$ </th>
            <td>$$q_4$$ </td>
            <td>$$q_4$$ </td>
            <td>$$q_4$$ </td>
            <td>$$q_3$$ </td>
        </tr>
        <tr>
            <th>$$q_3$$ </th>
            <td>$$q_1$$ </td>
            <td>$$q_4$$ </td>
            <td>$$q_4$$ </td>
            <td>$$q_3$$ </td>
        </tr>
        <tr>
            <th>$$q_4$$ </th>
            <td>$$q_4$$ </td>
            <td>$$q_4$$ </td>
            <td>$$q_4$$ </td>
            <td>$$q_4$$ </td>
        </tr>
        </tbody>
        <tbody></tbody>
    </table>
<figcaption>
    <strong>Table {{ page.tables[0].id | remove: "SC"  | split: "" | join: "." }}:</strong>
    {{ page.tables[0].caption }}
</figcaption>
</figure>


<p>
If we compare DFA's state diagram [Figure 1](#figure-1) and this definition, we see that transitions are more understandable. For example,
if I want to know next state from current $$q_2$$ given symbol <code class="d-code">)</code>, I just need to find
$$q_2$$ state in left column, then <code class="d-code">)</code> in the top row, and check which state is at their intersection ($$q_4$$).
</p>

<h2><a name="{{ page.headers[6].id }}"></a>{{ page.headers[6].name }}</h2>



Given all the information about DFA, it should not be hard to implement it. From the formal definition we see, that our automaton
has 4 states: $$q_0$$, $$q_1$$, $$q_2$$, $$q_3$$, $$q_4$$, which are known in advance. Thus, we can create `private enum States {...}`
to represent them. Nice thing about JAVA enum, is that you can define methods and instance variables in them. For example,
to differentiate accept and non accept states, we can introduce instance variable `final boolean accept;` for each state.


<a name="{{ page.code[0].id }}"></a>
<div class="env-header">
    Source code {{ page.code[0].id | remove: "SC"  | split: "" | join: "." }}
</div>
{% highlight java linenos %}
private enum States {

  Q0(false), Q1(false), Q2(true), Q3(true), Q4(false);

  final boolean accept;

  // Constructor for sate.
  // Every state is either accepting or not.
  States(boolean accept) {
    this.accept = accept;
  }

  //...
}
{% endhighlight %}

Just like that, we defined automaton's states $$Q$$ and a subset of accepting states $$F$$. Now, let's think how to implement
transition table. Probably your first thought is "We can use two dimensional array or a map or a hashtable". All these
solutions are good, and they would work. Unfortunately they are not very object oriented. Think of a state as being
an object, to which you can send some messages for enquiry or making them to do something for you. For example, we can
ask it, if it is an accept state or not? By introducing a method `boolean isAccept() {...}` which would return it's
instance variable `accept`. But in our case, it is not necessary, because `private enum States {...}` will be a member of
`public class DFA {...}`, thus all its variables will be accessible.


Similarly, given a character from the alphabet, we can ask a state to transit to another. So, instead of writing
transition table and then passing it to some kind of function, we will define method `States transition(char ch) {...}` inside
`private enum States {...}` to get next state. For that we will have to introduce additional instance variables in the enum.
Each variable will contain a reference to the state. I think, to show is much easier than to explain.


<div class="env-header">DFA transitions</div>
{% highlight java linenos %}
private enum States {

Q0(false), Q1(false), Q2(true), Q3(true), Q4(false);

States eyes;
States smile;
States sad;
States space;

static {
Q0.eyes = Q1; Q0.smile = Q4; Q0.sad = Q4; Q0.space = Q0;
Q1.eyes = Q4; Q1.smile = Q2; Q1.sad = Q2; Q1.space = Q4;
Q2.eyes = Q4; Q2.smile = Q4; Q2.sad = Q4; Q2.space = Q3;
Q3.eyes = Q1; Q3.smile = Q4; Q3.sad = Q4; Q3.space = Q3;
Q4.eyes = Q4; Q4.smile = Q4; Q4.sad = Q4; Q4.space = Q4;
}

States transition(char ch) {
switch (ch) {
case ':':
return this.eyes;
case ')':
return this.smile;
case '(':
return this.sad;
case '_':
return this.space;
default:
throw new RuntimeException("Symbol is " +
"not in the alphabet");
}
}

//...
}
{% endhighlight %}

First few lines are nothing new. On the Line 5, like I said, we are introducing some instance variables. There are four
symbols in the alphabet, thus each state will have four transitions. For example `States eyes;` represents a state, to which
current state would transit if input symbol would be <code class="d-code">:</code>.

Given these extra variables, we need to assign values to them. We do this in `static {...}` block. You may ask "Why can't we pass
values as arguments to the constructor, like we did for `final boolean accept;` variable. For two reasons:

1. **Forward referencing**. When we are trying to assign a state to the variable, some of the states are not have been
initialised. For example, to assign
`Q1` to `eyes` in `Q0` we need reference of `Q1`, but it is not initialised yet, so we get an error.
2. **Circular referencing**. It is similar to forward referencing. We are trying to pass non existing state to the constructor.
The difference is, that constructor belongs to the state itself. For example, passing `Q4` to `Q4` constructor.

On the other hand, in `static {...}` block all the states are initialised and available to use. For convenience, I arranged assignments of variables, so that
they would resemble transition table. Also, lets not forget about `States transition(char ch) {...}` method which checks what kind of
character is passed, and based on that returns next state. We could have transition function in `public class DFA {...}` class, it would
make no difference.

{::options parse_block_html="true" /}

<div class="note alert">
	**IMPORTANT:** Contrary to formal definition of DFA, in my implementation, transition function is not total, but
	partial. Because it maps
	only four characters from the alphabet (Unidocde). If input character is not one of the four, then exception is
	thrown. In theory, it should not happen. To fix that, I could create `private enum Alphabet {...}` with four members
	representing four charachters and change
	transition signature to `States transition(Alphabet symbol) {...}`. This way would be impossible to pass non
	existing characters of the alphabet to transition method.
</div>

{::options parse_block_html="false" /}

The only thing what is left is to create `public class DFA {...}` with the method `public boolean accept(String string) {...}` which checks
if a string belongs to the language.

<div class="env-header">DFA accept</div>
{% highlight java linenos %}
public class DFA {

private enum States {
//...
}

public boolean accept(String string) {
States state = States.Q0;

for (int i = 0; i < string.length(); i++) {
state = state.transition(string.charAt(i));
}
return state.accept;
}
}
{% endhighlight %}

## Additional notes

Using enums we can implement any DFA. Unfortunately they are not very flexible. Meaning, that if we would like to introduce
additional state or extra character, then we would need to modify enum itself, which violates
[Open/Close principle](https://en.wikipedia.org/wiki/Open/closed_principle). For that we could use
[state pattern](https://en.wikipedia.org/wiki/State_pattern). But if you are thinking about modification of DFA, then
probably your don't need DFA in the first place. Because by definition, DFA (Deterministic Finite Automaton) is **finite**,
meaning it has finite set of states, and **deterministic** - its next state is determined by input symbol.

[Download](https://gist.github.com/grrinchas/534614339f786c7528a588426f08d4ef)
